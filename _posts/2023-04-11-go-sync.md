---
layout: post
title: go sync
subtitle: synchronization primitives
tags: [go]
comments: true
---

### ⭐`sync` 标准库是 Go 语言中用于实现同步原语的包例如互斥锁（`sync.Mutex`）、读写锁（`sync.RWMutex`）和同步组（`sync.WaitGroup`)

**使用`sync.Cond`等待任务空闲**

```
type Queue struct {
	mu    *sync.Mutex
	cond  *sync.Cond
	jobs  []func() error
	limit int
}

func (q *Queue) push(j func() error) {
	q.mu.Lock()
	if len(q.jobs) >= q.limit {
		fmt.Println("Job limit exceeded, waiting for idle")
		q.cond.Wait()
	}
	q.jobs = append(q.jobs, j)
	q.mu.Unlock()
}

func (q *Queue) pop() func() error {
	q.mu.Lock()
	defer q.mu.Unlock()
	if len(q.jobs) == 0 {
		return nil
	}
	j := q.jobs[0]
	q.cond.Signal()
	return j
}

func New(limit int) Queue {
	var mu sync.Mutex
	return Queue{
		mu:    &mu,
		cond:  sync.NewCond(&mu),
		jobs:  nil,
		limit: limit,
	}
}

func main() {
	queue := New(1)
	wg1 := sync.WaitGroup{} //producer
	for i := 0; i < 10; i++ {
		wg1.Add(1)
		go func() {
			wg1.Done()
			j := func() error {
				fmt.Println(fmt.Sprintf("job run at %d", time.Now().Unix()))
				return nil
			}
			queue.push(j) //add job
		}()
	}

	wg2 := sync.WaitGroup{} //consumer

	for i := 0; i < 10; i++ {
		wg2.Add(1)
		go func() {
			defer wg2.Done()
			f := queue.pop() //get job
			f()              //exec job
		}()
	}

	wg1.Wait() //wait to exit
	wg2.Wait() //wait to exit
}
```

push: job数量达到限制的最大值，调用`cond.Wait()`使goroutine阻塞，等待条件满足.

pop: 在切片切片里面读取到一个job，此时job数量小于限制的最大值，调用`cond.Signal`或`cond.Broadcast`让push继续工作.

必须在独立的协程里面进程操作，否则可能导致死锁

---




